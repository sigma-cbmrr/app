<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="sigma-comum.css">
    <style>
        /* --- ESTILOS GERAIS --- */
        body { font-family: Arial, sans-serif; background-color: #f4f4f9; color: #333; min-height: 100vh; margin: 0; display: flex; flex-direction: column; align-items: center; padding-bottom: 90px; padding-top: 60px; box-sizing: border-box; }
        .container { background-color: #fff; padding: 20px; border-radius: 10px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); width: 95%; max-width: 700px; margin-bottom: 20px; text-align: center; box-sizing: border-box; }
        .loading-message { margin-top: 50px; font-size: 1.2em; color: #800020; font-weight: bold; } 
        h1 { color: #d90f23; margin-bottom: 3px; font-size: 1.6em; padding-bottom: 5px; border-bottom: 1px solid #e0e0e0; margin-bottom: 10px; }
        .subtitulo { font-size: 0.9em; color: #666; margin-bottom: 20px; font-weight: 600; text-transform: uppercase; }
        .user-info-display { font-size: 0.8em; color: #333; text-align: left; margin-top: -10px; margin-bottom: 15px; padding-bottom: 5px; border-bottom: 1px solid #eee; }
        
        /* SETORES E ITENS */
        .setor-header { background-color: #800020; color: white; padding: 12px 15px; margin-top: 20px; border-radius: 6px; cursor: pointer; text-align: left; font-weight: bold; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); transition: background-color 0.3s; }
        .setor-info { display: flex; align-items: center; gap: 10px; }
        .setor-status { background-color: #d90f23; color: white; font-size: 0.9em; padding: 3px 8px; border-radius: 4px; min-width: 35px; text-align: center; transition: background-color 0.3s; } .setor-status.ok { background-color: #1b8a3e; }
        .setor-content { padding: 10px 0; max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out, padding 0.4s ease-out; background-color: #fff; border-left: 1px solid #e0e0e0; border-right: 1px solid #e0e0e0; } .setor-content.expanded { max-height: 5000px; padding-bottom: 20px; border-bottom: 1px solid #e0e0e0; border-radius: 0 0 6px 6px; }
        .arrow { font-size: 1.2em; transition: transform 0.4s; }
        
        .item-conferencia { border: 1px solid #e0e0e0; border-left: 5px solid #ccc; border-radius: 6px; padding: 10px; margin: 10px; background-color: #fafafa; transition: border-left-color 0.3s ease, background-color 0.3s ease; }
        .item-conferencia.status-ok { border-left-color: #1b8a3e; background-color: #f0fff0; }
        .item-conferencia.status-alert { border-left-color: #d90f23; background-color: #fff0f0; }
        .item-conferencia.status-existing-alert { border-left-color: #ff9800; background-color: #fff8e1; }
        .item-conferencia.status-admin-response { border-left-color: #2196F3; background-color: #E3F2FD; } 
        
        .item-header { display: flex; flex-direction: column; justify-content: space-between; align-items: flex-start; margin-bottom: 5px; flex-wrap: wrap; }
        .item-label { font-weight: bold; color: #333; flex-grow: 1; margin-right: 10px; text-align: left; font-size: 0.95em; width: 100%; }
        .item-quantidade { font-size: 0.9em; color: #800020; font-weight: bold; flex-shrink: 0; margin-top: 5px; }
        .status-icon { font-weight: bold; font-size: 0; padding: 0; width: 18px; height: 18px; line-height: 18px; background-color: transparent; border: 1px dashed #aaa; display: inline-block; margin-right: 5px; vertical-align: middle; }
        .status-icon.ok { background-color: #1b8a3e; border: none; } .status-icon.ok:after { content: '‚úì'; font-size: 12px; line-height: 18px; color: white; display: block; text-align: center; }
        .status-icon.alert { background-color: #d90f23; border: none; } .status-icon.alert:after { content: 'C/A'; font-size: 10px; line-height: 18px; color: white; display: block; text-align: center; }
        
        .item-options { display: flex; justify-content: flex-end; margin-top: 5px; gap: 10px; padding-top: 5px; border-top: 1px solid #f0f0f0; }
        .action-button { padding: 8px 15px; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-weight: bold; font-size: 0.9em; transition: background-color 0.2s, color 0.2s, border-color 0.2s; background-color: #f0f0f0; color: #333; }
        .action-button.active.sa-ok { background-color: #1b8a3e; color: white; border-color: #1b8a3e; } .action-button.active.ca-alert { background-color: #d90f23; color: white; border-color: #d90f23; }
        
        /* ESTILOS PEND√äNCIAS */
        .pendencia-alert-box { font-size: 0.85em; margin-top: 5px; display: block; text-align: left; border-left: 3px solid #d90f23; padding-left: 8px; background-color: #fff0f0; padding: 5px; transition: all 0.3s; }
        .pendencia-alert-box.admin-reply { border-left-color: #2196F3; background-color: #e3f2fd; }
        .pendencia-alert-box.kept { border-left-color: #1b8a3e; background-color: #f0fff0; opacity: 0.9; }
        
        .lista-pendencias { list-style: none; padding: 0; margin: 5px 0; }
        .lista-pendencias li { margin-bottom: 6px; display: block; padding-left: 5px; text-align: left; line-height: 1.3; border-bottom: 1px dotted #eee; padding-bottom: 4px; }
        .lista-pendencias li:last-child { border-bottom: none; }
        
        .texto-admin { font-weight: bold; color: #0d47a1; }
        .linha-obs { color: #333; font-weight: 500; }
        
        .pendencia-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 10px; border-top: 1px dotted #ccc; padding-top: 5px; }
        .btn-manter { background-color: #e0e0e0; border: 1px solid #ccc; color: #333; font-size: 0.8em; padding: 5px 10px; cursor: pointer; border-radius: 4px; } 
        .btn-acrescentar { background-color: #e0e0e0; border: 1px solid #ccc; color: #333; font-size: 0.8em; padding: 5px 10px; cursor: pointer; border-radius: 4px; }

        .historico-fixo { background-color: #eeeeee; border: 1px solid #ccc; color: #555; padding: 8px; border-radius: 4px; font-size: 0.85em; margin-bottom: 5px; font-style: italic; display: none; }
        .tombamento-container { border-top: 1px dotted #eee; margin-top: 5px; padding-top: 5px; text-align: left; padding-bottom: 5px; }
        .tombamento-controls { display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; }
        .tombamento-options { display: flex; gap: 5px; } .tombamento-options .action-button { padding: 5px 10px; font-size: 0.8em; margin: 0; }
        .tombamento-obs-container, .alteracao-container { margin-top: 10px; padding-top: 10px; border-top: 1px dashed #d90f23; display: none; text-align: left; }
        .tombamento-obs-container label, .alteracao-container label { display: block; margin-bottom: 5px; font-weight: bold; color: #d90f23; font-size: 0.85em; }
        .tombamento-obs-container textarea, .alteracao-container textarea { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #d90f23; box-sizing: border-box; font-size: 0.85em; resize: vertical; min-height: 40px; margin-bottom: 5px; }
        .btn-salvar-alteracao { background-color: #800020; color: white; font-weight: bold; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; width: 100%; transition: background-color 0.3s; font-size: 0.85em; }
        .descricao-salva, .tombamento-descricao-salva { font-size: 0.9em; margin-top: 5px; display: none; padding-top: 5px; border-top: 1px dashed #ddd; text-align: left; background-color: #fff8f8; padding: 8px; border-radius: 4px; }
        
        #btn-finalizar { background-color: #d90f23; color: white; font-weight: bold; border: none; padding: 15px 10px; border-radius: 6px; width: 100%; cursor: pointer; transition: background-color 0.3s ease; margin-top: 30px; font-size: 1.1em; box-shadow: 0 4px 8px rgba(217, 15, 35, 0.4); }
        #btn-finalizar:disabled { background-color: #999; cursor: not-allowed; box-shadow: none; }
        
        .draft-badge { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; padding: 10px; margin-bottom: 15px; border-radius: 6px; font-size: 0.9em; text-align: center; display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1 id="titulo-conferencia">Confer√™ncia de Materiais</h1>
        <p class="subtitulo" id="local-posto-info">Carregando Local...</p>
        <p id="militar-info" class="user-info-display">Carregando dados do conferente...</p>
        <div id="draft-message" class="draft-badge"><strong>Rascunho recuperado:</strong> Voc√™ est√° continuando de onde parou.</div>
        <div id="loading-message" class="loading-message">Inicializando sistema...</div>
        <div id="main-content" style="display: none;">
            <button id="btn-finalizar" onclick="finalizarConferencia()" disabled>FINALIZAR CONFER√äNCIA (0/X ITENS)</button>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>

    <script>
        const firebaseConfig = { apiKey: "AIzaSyCB0PH0UgghgsvH0BgPkG4AkKON6xSQ9mc", authDomain: "sigma-cbmrr.firebaseapp.com", projectId: "sigma-cbmrr", storageBucket: "sigma-cbmrr.firebasestorage.app", messagingSenderId: "378026276038", appId: "1:378026276038:web:620dd6ff57501b1a8313c7" };
        if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        const urlParams = new URLSearchParams(window.location.search);
        const LISTA_ID = urlParams.get('id'); 
        const COLECAO_LISTAS = 'listas_conferencia';
        let MODO_OPERACAO = 'recebimento'; // Novo: 'recebimento' (padr√£o) ou 'devolucao'
        let DESTINATARIO_DEVOLUCAO = null; // Novo: O √∫ltimo conferente que ir√° receber de volta.
        // üõë CR√çTICO: Deve ser 'cautelaId' para coincidir com o envio do iframe
        const CAUTELA_ID = urlParams.get('cautelaId');
        const modoParam = urlParams.get('modo');
            if (modoParam === 'devolucao_final') {
                MODO_OPERACAO = 'devolucao_final';
                DESTINATARIO_DEVOLUCAO = urlParams.get('destinatarioDevolucao');
            }
        // üõë CR√çTICO: Deve estar definida
        const COLECAO_CAUTELAS = 'cautelas_abertas';
        const COLECAO_RESULTADOS = 'resultados_conferencias';
        let dadosConferencia = [];
        let isCautela = !!CAUTELA_ID;
        let infoLocal = { nome: '', posto: '' }; window.itemStatus = {};

        function getUrlParameter(n) { return (new URLSearchParams(window.location.search)).get(n) || ''; }
        const userInfo = { postoGraduacao: getUrlParameter('posto_grad') || "ND", quadro: getUrlParameter('quadro_mil') || "ND", nomeGuerra: getUrlParameter('nome_guerra') || "ND" };

        function formatarDataSimples(timestamp) {
            if (!timestamp) return "";
            const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
            return date.toLocaleDateString('pt-BR'); 
        }

        function updateHeaderInfo() { 
            const el = document.getElementById('militar-info');
            if(el) el.innerHTML = `<strong>Conferente:</strong> ${userInfo.postoGraduacao} ${userInfo.quadro} ${userInfo.nomeGuerra}<br><strong>Data/Hora:</strong> ${new Date().toLocaleString()}`; 
        }

        function updateOverallStatus() { 
            let total = 0, completed = 0; 
            document.querySelectorAll('.setor').forEach(s => { 
                total += parseInt(s.dataset.totalItems || 0); 
                completed += parseInt(s.querySelector('.setor-status').dataset.completed || 0); 
            }); 
            const btn = document.getElementById('btn-finalizar'); 
            if(btn) {
                btn.textContent = `FINALIZAR CONFER√äNCIA (${completed}/${total} ITENS)`; 
                let buttonPrefix = 'FINALIZAR CONFER√äNCIA';
    // MODO_OPERACAO √© global e foi definido no in√≠cio do script
    if (typeof MODO_OPERACAO !== 'undefined' && MODO_OPERACAO === 'devolucao') {
        buttonPrefix = 'FINALIZAR DEVOLU√á√ÉO';
    }
    
    if(btn) {
        // Altera a linha original para usar o prefixo condicional
        // A contagem (completed/total) √© mantida.
        btn.textContent = `${buttonPrefix} (${completed}/${total} ITENS)`;

        if (total > 0 && completed >= total) {
            btn.disabled = false;
            // ... (estilo para verde) ...
        } else {
            btn.disabled = true;
            // ... (estilo para vermelho) ...
        }
    }
                if (total > 0 && completed >= total) {
                    btn.disabled = false;
                    btn.style.backgroundColor = '#1b8a3e'; 
                    btn.style.cursor = 'pointer';
                } else {
                    btn.disabled = true;
                    btn.style.backgroundColor = '#d90f23'; 
                    btn.style.cursor = 'not-allowed';
                }
            }
        }

        function updateSetorStatus(setorEl) { 
            const items = setorEl.querySelectorAll('.item-conferencia'); 
            let completed = 0, total = 0; 
            items.forEach(item => { 
                if (item.dataset.type === 'single') { 
                    total++; const s = window.itemStatus[item.dataset.id]?.status; 
                    if (s === 'S/A' || s === 'C/A' || s === 'KEEP') completed++;
                } else { 
                    const tombs = item.querySelectorAll('.tombamento-container'); 
                    tombs.forEach(t => { 
                        total++; const s = window.itemStatus[`${item.dataset.id}-${t.dataset.tomb}`]?.status; 
                        if (s === 'S/A' || s === 'C/A' || s === 'KEEP') completed++;
                    }); 
                } 
            }); 
            setorEl.dataset.totalItems = total; 
            const st = setorEl.querySelector('.setor-status'); 
            st.dataset.completed = completed; 
            if (completed === total && total > 0) { st.textContent = 'OK'; st.classList.add('ok'); } 
            else { st.textContent = `${completed}/${total}`; st.classList.remove('ok'); } 
        }

        function updateItemMainStatusDisplay(item) { 
            if (item.dataset.type === 'single') return; 
            const tombs = item.querySelectorAll('.tombamento-container'); let conf = 0, alt = 0; 
            tombs.forEach(t => { 
                const s = window.itemStatus[`${item.dataset.id}-${t.dataset.tomb}`]?.status; 
                if (s === 'S/A' || s === 'C/A' || s === 'KEEP') { conf++; if (s === 'C/A' || s === 'KEEP') alt++; } 
            }); 
            const icon = item.querySelector('.status-icon'); item.className = 'item-conferencia item-has-tombamentos'; icon.className = 'status-icon'; 
            if (conf === tombs.length) { 
                if (alt > 0) { icon.classList.add('alert'); item.classList.add('status-alert'); } 
                else { icon.classList.add('ok'); item.classList.add('status-ok'); } 
            } 
        }

        function toggleSetor(header) { 
            const content = header.nextElementSibling; const arrow = header.querySelector('.arrow'); 
            if (content.classList.contains('expanded')) { content.classList.remove('expanded'); arrow.textContent = '‚ñ∫'; } 
            else { document.querySelectorAll('.setor-content.expanded').forEach(c=>{c.classList.remove('expanded'); c.previousElementSibling.querySelector('.arrow').textContent='‚ñ∫';}); content.classList.add('expanded'); arrow.textContent = '‚ñº'; } 
        }

        function checkSetorCompletion(setor, itemId) {
    const itemEl = setor.querySelector(`.item-conferencia[data-id="${itemId}"]`);
    if (!itemEl) return;

    // L√≥gica para determinar se um ITEM est√° completo
    let isItemCompleted = false;

    // 1. Verifica itens sem tombamento (single)
    if (!itemEl.querySelector('.tombamento-container')) {
        const itemStatus = window.itemStatus[itemId];
        // Verifica se o estoque dispon√≠vel √© 0 (fechado por C/A) ou se foi marcado S/A
        const isFullyAccounted = itemEl.querySelector('.item-quantidade').textContent.match(/^0\s+DISP/);
        
        if (itemStatus && (itemStatus.status === 'S/A' || isFullyAccounted)) {
            isItemCompleted = true;
        }
    } 
    // 2. Verifica itens com tombamento (multi)
    else {
        const todosTombamentos = itemEl.querySelectorAll('.tombamento-container');
        let todosTombamentosCompletos = true;
        
        todosTombamentos.forEach(tomb => {
            const uid = `${itemId}-${tomb.dataset.tomb}`;
            const tombStatus = window.itemStatus[uid]?.status;
            // Tombamento √© completo se status for S/A, C/A, ou CIENTE
            if (!tombStatus || (tombStatus !== 'S/A' && tombStatus !== 'C/A' && tombStatus !== 'CIENTE')) {
                todosTombamentosCompletos = false;
            }
        });
        
        if (todosTombamentosCompletos) {
            isItemCompleted = true;
        }
    }

    // üõë ADICIONA O REQUISITO DE UX (ROLAGEM) üõë
    if (isItemCompleted) {
        // Encontra o pr√≥ximo item pendente e rola para ele
        scrollToNextPendingItem(itemId);
    }

    // L√≥gica para verificar a conclus√£o do SETOR
    const allItems = setor.querySelectorAll('.item-conferencia');
    let setorCompleto = true;
    
    // Itera sobre todos os itens do setor para verificar se todos foram conferidos
    allItems.forEach(i => {
        const iId = i.dataset.id;
        
        // Se for item single E n√£o estiver completo (S/A ou C/A/0 DISP)
        if (!i.querySelector('.tombamento-container')) {
            const iStatus = window.itemStatus[iId];
            const isFullyAccounted = i.querySelector('.item-quantidade').textContent.match(/^0\s+DISP/);
            
            if (!iStatus || (iStatus.status !== 'S/A' && iStatus.status !== 'C/A' && !isFullyAccounted)) {
                setorCompleto = false;
            }
        } 
        // Se for item multi (com tombamento) E pelo menos um tombamento estiver pendente
        else {
            const tombamentos = i.querySelectorAll('.tombamento-container');
            tombamentos.forEach(t => {
                const uid = `${iId}-${t.dataset.tomb}`;
                const tStatus = window.itemStatus[uid]?.status;
                if (!tStatus || (tStatus !== 'S/A' && tStatus !== 'C/A' && tStatus !== 'CIENTE')) {
                    setorCompleto = false;
                }
            });
        }
    });

    if (setorCompleto) {
        setor.classList.add('setor-completed');
    } else {
        setor.classList.remove('setor-completed');
    }
}
        
        function autoAdvanceSetor(sid) { 
            const s = document.querySelector(`.setor[data-id="${sid}"]`); 
            if (s) toggleSetor(s.querySelector('.setor-header')); 
            const idx = window.setorIds.indexOf(sid); const nextId = window.setorIds[idx + 1]; 
            if (nextId) { 
                const next = document.querySelector(`.setor[data-id="${nextId}"]`); 
                if (next) { const h = next.querySelector('.setor-header'); toggleSetor(h); next.scrollIntoView({ behavior: 'smooth', block: 'center' }); } 
            } 
        }
        function isElementInViewport(el) { const rect = el.getBoundingClientRect(); return (rect.top >= 60 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth)); }
        function getStorageKey() { return `sigma_draft_${LISTA_ID}_${userInfo.nomeGuerra}`; }
        function salvarRascunho() { try { localStorage.setItem(getStorageKey(), JSON.stringify({ timestamp: Date.now(), status: window.itemStatus })); } catch (e) {} }
        function limparRascunho() {
            localStorage.removeItem('sigma_active_conf');
            const listId = CAUTELA_ID || LISTA_ID; // Pega o ID da lista ou cautela
            const userId = (userInfo && userInfo.nomeGuerra) 
            ? userInfo.nomeGuerra.toUpperCase() 
            : null;

            if (listId && userId) {
                // Esta chave DEVE ser a mesma usada na fun√ß√£o salvarRascunho()
                const draftKey = `sigma_draft_${userId}_${listId}`; 
                localStorage.removeItem(draftKey);
                console.log(`Rascunho local (${draftKey}) limpo com sucesso.`);
            }
        }

        const gerarLinhasFormatadas = (textoBruto, autorAtual, dataAtual, adminStatus, adminObs) => {
            const linhas = [];
            if (adminStatus) linhas.push(`[${adminStatus.toUpperCase()}] (Admin): ${adminObs}`);
            const separator = ' | + NOVA: ';
            if (textoBruto.includes(separator)) {
                const partes = textoBruto.split(separator);
                partes.forEach(p => {
                    p = p.trim();
                    const regex = /^"(.*)" \(Por: (.*) em (.*)\)$/; const match = p.match(regex);
                    if (match) linhas.push(`Por: ${match[2]} em ${match[3]}: "${match[1]}"`);
                    else linhas.push(`Por: ${autorAtual} em ${dataAtual}: "${p}"`);
                });
            } else {
                const p = textoBruto.trim();
                const regex = /^"(.*)" \(Por: (.*) em (.*)\)$/; const match = p.match(regex);
                if (match) linhas.push(`Por: ${match[2]} em ${match[3]}: "${match[1]}"`);
                else linhas.push(`Por: ${autorAtual} em ${dataAtual}: "${p}"`);
            }
            return linhas;
        };
        const gerarHtmlVisual = (textoBruto, autorAtual, dataAtual, adminStatus, adminObs) => {
            const linhas = gerarLinhasFormatadas(textoBruto, autorAtual, dataAtual, adminStatus, adminObs);
            let html = '<ul class="lista-pendencias">';
            linhas.forEach(l => { if (l.includes('(Admin):')) { const parts = l.split('): '); html += `<li><span class="texto-admin">‚ö†Ô∏è ${parts[0]}):</span> Resp: ${parts[1]}</li>`; } else { html += `<li class="linha-obs">‚Ä¢ ${l}</li>`; } });
            html += '</ul>'; return html;
        };
        const montarHistoricoLinear = (obsAnterior, novoTexto, autorAnterior, dataAnterior) => {
    const separator = ' | + NOVA: ';
    
    // Este bloco lida com a adi√ß√£o a uma cadeia de observa√ß√µes
    if (obsAnterior.includes(separator)) {
        let partes = obsAnterior.split(separator); 
        let ultimaParte = partes.pop(); 
        let resto = partes.join(separator); 
        // Assina a √∫ltima parte n√£o assinada (o texto puro)
        let ultimaAssinada = `"${ultimaParte}" (Por: ${autorAnterior} em ${dataAnterior})`; 
        return `${resto}${separator}${ultimaAssinada}${separator}${novoTexto}`;
    } else { 
        // CORRE√á√ÉO: Este bloco √© ativado na primeira adi√ß√£o. 
        // Como 'obsAnterior' j√° est√° assinado pela fun√ß√£o salvarItem/salvarTombamento, 
        // apenas anexamos o novo texto com o separador, sem re-assinar.
        return `${obsAnterior}${separator}${novoTexto}`; 
    }
};

        /**
 * Renderiza a estrutura principal da confer√™ncia, calculando a disponibilidade (DISPON√çVEL vs. TOTAL).
 */
function renderizarConferencia() {
    const mainContent = document.getElementById('main-content');
    const antigos = mainContent.querySelectorAll('.setor');
    antigos.forEach(el => el.remove());
    let htmlSetores = '';
    const setorIds = [];
    dadosConferencia.forEach(s => setorIds.push(s.id));
    window.setorIds = setorIds;

    dadosConferencia.forEach((setor, index) => {
        const isFirstSetor = (index === 0);
        let htmlItens = '';
        let totalItensNoSetor = 0;
        
        setor.itens.forEach(item => {
            
            let totalEsperado = item.quantidadeEsperada || 0;
            let totalCautelado = item.quantidadeCautelada || 0;
            let totalComAlteracao = item.quantidadeComAlteracao || 0;
            let totalDisponivel = totalEsperado;
            
            let isCautelado = false;
            let isAnyTombCautelado = false;
            let totalIndisponivel = 0;

            if (item.tipo === 'multi' && item.tombamentos && item.tombamentos.length > 0) {
                totalEsperado = item.tombamentos.length;
                
                const indisponiveis = item.tombamentos.filter(tomb => 
                    tomb.cautela_id || (tomb.status_conferencia === 'CA')
                );
                
                totalIndisponivel = indisponiveis.length;
                totalDisponivel = totalEsperado - totalIndisponivel;
                
                isAnyTombCautelado = item.tombamentos.some(tomb => tomb.cautela_id);

            } else if (item.tipo === 'single') {
                totalIndisponivel = totalCautelado + totalComAlteracao;
                totalDisponivel = totalEsperado - totalIndisponivel;
                
                isCautelado = totalCautelado > 0;
            }

            const isItemIniciado = totalEsperado > 0;
            
            const isSA_disabled = isAnyTombCautelado || isCautelado ? 'disabled' : '';
            const isCA_disabled = isAnyTombCautelado && item.tipo === 'multi' ? 'disabled' : '';


            if (isItemIniciado) {
                
                const pendenciaHtml = renderizarPendencia(item);
                
                let classExtra = '';
                if (totalIndisponivel > 0 || item.pendencia) {
                    classExtra = 'status-existing-alert';
                }
                
                if (item.tipo === 'multi') {
                    
                    htmlItens += `<div class="item-conferencia item-has-tombamentos ${classExtra}" data-type="multi" data-total-tombamentos="${totalEsperado}" data-status="pending" data-id="${item.id}">
                                    <div class="item-header">
                                        <span class="status-icon"></span>
                                        <span class="item-label">${item.nome}</span>
                                        <span class="item-quantidade">
                                            ${totalDisponivel} DISP. / ${totalEsperado} TOTAL
                                        </span>
                                    </div>
                                    ${pendenciaHtml}
                                    ${renderizarTombamentos(item)}
                                  </div>`;
                    
                    totalItensNoSetor += totalEsperado;
                    
                } else {
                    
                    htmlItens += `<div class="item-conferencia ${classExtra}" data-type="single" data-status="pending" data-id="${item.id}">
                                    <div class="item-header">
                                        <span class="status-icon"></span>
                                        <span class="item-label">${item.nome}</span>
                                        <span class="item-quantidade">
                                            ${totalDisponivel} DISP. / ${totalEsperado} TOTAL
                                        </span>
                                    </div>
                                    <div class="item-options">
                                        <button class="action-button sa-ok" onclick="setItemStatus(this, 'ok')" ${isSA_disabled}>S/A</button>
                                        <button class="action-button ca-alert" onclick="setItemStatus(this, 'alert')" ${isCA_disabled}>C/A</button>
                                    </div>
                                    ${pendenciaHtml}
                                    <p class="descricao-salva"></p>
                                    <div class="alteracao-container">
                                        <div class="historico-fixo" style="display:none;"></div>
                                        <label>Descreva a altera√ß√£o (QTD Dispon√≠vel: ${totalDisponivel}):</label>
                                        <textarea data-id="${item.id}" placeholder="Descreva a altera√ß√£o."></textarea>
                                        <button type="button" class="btn-salvar-alteracao" onclick="salvarItem(this)">SALVAR</button>
                                    </div>
                                  </div>`;
                    totalItensNoSetor++;
                }
                
                window.itemStatus[item.id] = { status: 'pending', obs: '' };
            }
        });
        
        const expandedClass = isFirstSetor ? 'expanded' : '';
        const arrowChar = isFirstSetor ? '‚ñº' : '‚ñ∫';
        
        htmlSetores += `<div class="setor" data-total-items="${totalItensNoSetor}" data-id="${setor.id}">
                            <div class="setor-header" onclick="toggleSetor(this)">
                                <div class="setor-info">
                                    <span>${setor.nome}</span>
                                    <div class="setor-status" data-completed="0">0/${totalItensNoSetor}</div>
                                </div>
                                <span class="arrow">${arrowChar}</span>
                            </div>
                            <div class="setor-content ${expandedClass}">${htmlItens}</div>
                        </div>`;
    });
    
    mainContent.querySelector('#btn-finalizar').insertAdjacentHTML('beforebegin', htmlSetores);
    updateOverallStatus();
}

/**
 * Renderiza o bloco de hist√≥rico/pend√™ncias (incluindo a l√≥gica do 'Ciente' para cautelas).
 */
function renderizarPendencia(mItem) {
    if (!mItem.pendencia || !mItem.pendencia.obs) {
        return '';
    }

    // Pend√™ncia HTML deve usar a mesma estrutura de um item alterado
    const uid = mItem.id;
    const pendenciaObj = mItem.pendencia;
    
    // Conte√∫do formatado (Log imut√°vel)
    const obs = pendenciaObj.obs ? pendenciaObj.obs.replace(/'/g, "\\'") : '';
    const quem = pendenciaObj.quem || 'An√¥nimo';
    const dataPend = formatarDataSimples(pendenciaObj.data);
    const dadosHistorico = JSON.stringify({ obs: obs, autor: quem, data: dataPend });
    const safeHistorico = encodeURIComponent(dadosHistorico);
    const htmlFormatado = gerarHtmlVisual(obs, quem, dataPend, pendenciaObj.statusAdmin, pendenciaObj.adminObs);

    let classAdmin = pendenciaObj.statusAdmin ? "admin-reply" : "";
    
    // üõë L√ìGICA DO BOT√ÉO "CIENTE" PARA CAUTELA üõë
    let manterButtonText = '‚úÖ Concordo (Manter)';
    if (pendenciaObj.status === 'CAUTELADO') {
        manterButtonText = '‚úÖ Ciente (Item Cautelado)';
    }


    return `<div class="pendencia-alert-box ${classAdmin}">
                ${htmlFormatado}
                <div class="pendencia-actions">
                    <button class="btn-manter" onclick="manterPendencia(this, '${uid}')">${manterButtonText}</button>
                    <button class="btn-acrescentar" onclick="acrescentarPendencia(this, '${uid}', '${safeHistorico}')">‚ûï Acrescentar</button>
                </div>
            </div>`;
}

/**
 * Renderiza a lista de tombamentos e suas a√ß√µes (Somente para tipo 'multi').
 */
function renderizarTombamentos(mItem) {
    if (mItem.tipo !== 'multi' || !mItem.tombamentos) return '';
    
    let tombsHtml = '<div class="tombamentos-list-container">';
    
    mItem.tombamentos.forEach(tomb => {
        
        const uid = `${mItem.id}-${tomb.tomb}`;
        
        let tombStatusText = 'Dispon√≠vel';
        let tombStatusBadge = 'bg-secondary';
        
        // L√≥gica de Status (Cautela > C/A > OK)
        if (tomb.cautela_id) {
            tombStatusText = `CAUTELADO (${tomb.cautela_id.replace('CAUTELA-', '')})`;
            tombStatusBadge = 'bg-primary';
        } else if (tomb.status_conferencia === 'OK') {
            tombStatusText = 'Conferido S/A';
            tombStatusBadge = 'bg-success';
        } else if (tomb.status_conferencia === 'CA') {
            tombStatusText = 'C/A';
            tombStatusBadge = 'bg-warning';
        }

        // üõë Bloqueio: Tombamento Cautelado n√£o pode ter a√ß√µes S/A ou C/A
        const isTombCautelado = !!tomb.cautela_id;
        const disabledAttrTomb = isTombCautelado ? 'disabled' : '';

        // O HIST√ìRICO INDIVIDUAL (SE EXISTIR) DEVE SER EXIBIDO DENTRO DO TOMBAMENTO
        const pendenciaHtml = renderizarPendencia(tomb);


        tombsHtml += `
            <div class="tombamento-container" data-tomb="${tomb.tomb}" data-item-id="${mItem.id}">
                <div class="tombamento-controls">
                    <span>Tomb.: <strong>${tomb.tomb}</strong></span>
                    <span class="badge ${tombStatusBadge} ms-2">${tombStatusText}</span>
                    <div class="tombamento-options">
                        <button class="action-button sa-ok" onclick="setTombamentoStatus(this, 'ok')" ${disabledAttrTomb}>S/A</button>
                        <button class="action-button ca-alert" onclick="setTombamentoStatus(this, 'alert')" ${disabledAttrTomb}>C/A</button>
                    </div>
                </div>
                ${pendenciaHtml}
                <p class="tombamento-descricao-salva"></p>
                <div class="tombamento-obs-container">
                    <div class="historico-fixo" style="display:none;"></div>
                    <label>Descreva a altera√ß√£o:</label>
                    <textarea placeholder="Detalhe a altera√ß√£o."></textarea>
                    <button type="button" class="btn-salvar-alteracao" onclick="salvarTombamento(this)">SALVAR OBSERVA√á√ÉO</button>
                </div>
            </div>
        `;
    });
    
    tombsHtml += '</div>';
    return tombsHtml;
}
        
function setTombamentoStatus(btn, status) { 
    const tomb = btn.closest('.tombamento-container'); 
    const item = btn.closest('.item-conferencia'); 
    const setor = btn.closest('.setor'); 
    const uid = `${item.dataset.id}-${tomb.dataset.tomb}`; 

    tomb.querySelectorAll('.action-button').forEach(b => b.classList.remove('active')); 
    btn.classList.add('active'); 

    tomb.querySelector('.tombamento-obs-container').style.display = 'none'; 
    tomb.querySelector('.tombamento-descricao-salva').style.display = 'none'; 
    
    const pb = tomb.querySelector('.pendencia-alert-box'); 
    if(pb) pb.style.display = 'none'; 

    if(status === 'ok'){
        window.itemStatus[uid] = { status: 'S/A', obs: '' }; 
        updateItemMainStatusDisplay(item);
    } else {
        tomb.querySelector('.tombamento-obs-container').style.display = 'block'; 
        window.itemStatus[uid] = { status: 'PENDING_CA', obs: '' }; 
        tomb.querySelector('textarea').focus(); 
        updateItemMainStatusDisplay(item);
    } 

    salvarRascunho(); 
    updateSetorStatus(setor); 
    updateOverallStatus(); 
    if(status === 'ok') checkSetorCompletion(setor, item.dataset.id); 
}
       function setItemStatus(btn, status) { 
    const item = btn.closest('.item-conferencia'); 
    const setor = btn.closest('.setor');
    const itemId = item.dataset.id;
    
    // Remove o estado ativo de todos os bot√µes e ativa o clicado
    item.querySelectorAll('.action-button').forEach(b => b.classList.remove('active')); 
    btn.classList.add('active'); 
    
    // Oculta elementos de edi√ß√£o/descri√ß√£o antigos
    item.querySelector('.descricao-salva').style.display = 'none'; 
    const alteracaoContainer = item.querySelector('.alteracao-container');
    if (alteracaoContainer) alteracaoContainer.style.display = 'none';
    
    const pb = item.querySelector('.pendencia-alert-box'); 
    if (pb) pb.style.display = 'none'; 
    
    if (status === 'ok') {
        // Fluxo S/A (Bot√£o Desfazer/Marcar OK):
        // Zera o rastreamento de C/A e marca o item como 100% S/A.
        item.className = 'item-conferencia status-ok'; 
        item.querySelector('.status-icon').className = 'status-icon ok'; 
        
        window.itemStatus[itemId] = { status: 'S/A', obs: '', qtd_alterada: 0 }; 
        
        recalcularESyncDisplay(item, setor); // Atualiza o display e checa avan√ßo
        
    } else {
        // Fluxo C/A: Inicia o novo lan√ßamento com prompt
        lancarNovaAlteracao(itemId, false); 
        return; // Sai da fun√ß√£o, pois a atualiza√ß√£o √© feita em lancarNovaAlteracao
    } 
    
    salvarRascunho(); 
}
        /**
 * Lida com o clique no bot√£o "Concordo (Manter)" ou "Ciente (Item Cautelado)".
 * Implementa a l√≥gica de bloqueio e reabilita√ß√£o p√≥s-Ci√™ncia.
 */
function manterPendencia(btn, uid) {
    const box = btn.closest('.pendencia-alert-box');
    const container = box.closest('.tombamento-container') || box.closest('.item-conferencia');
    
    if (!container) return;
    
    // Identifica o item principal para checar o status de cautela
    const itemId = container.dataset.itemId;
    const isTombamento = container.classList.contains('tombamento-container');
    
    // Busca o objeto Mestre do item para verificar o status de CAUTELADO
    let itemMestre = dadosConferencia.flatMap(s => s.itens).find(i => i.id === itemId);
    
    // Se for Tombamento, verifica o tombamento espec√≠fico
    if (isTombamento && itemMestre && itemMestre.tombamentos) {
        const tomb = container.dataset.tomb;
        itemMestre = itemMestre.tombamentos.find(t => `${itemId}-${t.tomb}` === uid) || itemMestre;
    }

    const isCautela = itemMestre && itemMestre.pendencia && itemMestre.pendencia.status === 'CAUTELADO';
    
    if (box) {
        box.querySelector('.pendencia-actions').style.display = 'none';
        box.classList.add('kept');
        
        let logMessage = '‚úî Mantido';
        let statusToSet = 'KEEP';

        if (isCautela) {
            // Se for Cautela, registra como 'Ciente' e marca o status final como C/A (Alterado)
            logMessage = '‚úî Ciente da Cautela';
            statusToSet = 'CA'; // Marca como C/A para o tracking da lista (totalmente indispon√≠vel)
        }
        
        box.insertAdjacentHTML('beforeend', `<div style="color:#1b8a3e;font-weight:bold;font-size:0.9em;margin-top:5px;border-top:1px dashed #ccc;padding-top:3px;">${logMessage}</div>`);
        window.itemStatus[uid] = { status: statusToSet, obs: '' };
        
        // --- L√ìGICA DE CONTROLE DE BOT√ïES P√ìS-CI√äNCIA ---
        
        const itemPrincipal = container.closest('.item-conferencia'); 
        const btnSA = itemPrincipal.querySelector('.action-button.sa-ok');
        const btnCA = itemPrincipal.querySelector('.action-button.ca-alert');
        
        // 1. Marca o status principal como C/A (para tombados ou single cautelado)
        if (btnCA) btnCA.classList.add('active');
        if (btnSA) btnSA.classList.remove('active');
        
        // 2. Regra de Reabilita√ß√£o (Itens SEM Tombamento)
        if (itemPrincipal.dataset.type === 'single') {
            // Se for SINGLE, reabilita o C/A para que o conferente possa lan√ßar novas pend√™ncias nas unidades restantes.
            if (btnCA) btnCA.disabled = false;
        }

        // 3. Regra de Bloqueio (Itens COM Tombamento)
        if (itemPrincipal.dataset.type === 'multi') {
            // Ap√≥s a Ci√™ncia/Manter em um item MULTI, ele est√° FINALIZADO (n√£o pode mais S/A nem C/A novo)
            if (btnSA) btnSA.disabled = true;
            if (btnCA) btnCA.disabled = true;
        }

        // Atualiza√ß√£o de Status
        if (container.classList.contains('tombamento-container')) {
            updateItemMainStatusDisplay(itemPrincipal);
        }
        
        const setor = container.closest('.setor');
        updateSetorStatus(setor);
        updateOverallStatus();
        checkSetorCompletion(setor, itemPrincipal.dataset.id);
        salvarRascunho();
    }
}

/**
 * Lida com o clique no bot√£o "Acrescentar".
 * O fluxo de cautela n√£o precisa de grandes mudan√ßas aqui.
 */
function acrescentarPendencia(btn, uid, encodedData) {
    const box = btn.closest('.pendencia-alert-box');
    const container = box.closest('.tombamento-container') || box.closest('.item-conferencia');
    box.style.display = 'none';
    
    if (container) {
        const itemPrincipal = container.closest('.item-conferencia');
        const btnCA = itemPrincipal.querySelector('.ca-alert');
        const btnSA = itemPrincipal.querySelector('.sa-ok');
        
        if (btnCA) {
            btnCA.classList.add('active');
        }
        if (btnSA) {
            btnSA.classList.remove('active');
        }
        
        const edit = container.querySelector('.tombamento-obs-container') || container.querySelector('.alteracao-container');
        edit.style.display = 'block';
        
        const hist = edit.querySelector('.historico-fixo');
        if (hist) {
            hist.dataset.meta = encodedData;
            hist.style.display = 'none';
        }
        
        const textarea = edit.querySelector('textarea');
        if (textarea) {
            textarea.value = '';
            textarea.focus();
        }
        
        // A√ß√µes de Altera√ß√£o
        window.itemStatus[uid] = { status: 'PENDING_CA', obs: '' };
        salvarRascunho();
    }
}

        function salvarItem(btn) { 
    const item = btn.closest('.item-conferencia'); 
    const obsRaw = item.querySelector('textarea').value.trim(); 
    const hist = item.querySelector('.historico-fixo'); 
    let final = obsRaw; 

    // üõë NOVO: Tenta extrair a quantidade da observa√ß√£o bruta (Ex: "Quebrado QTD: 2")
    const qtdMatch = obsRaw.match(/(?:QTD|QUANTIDADE|UN|UNIDADES)[:\s]*(\d+)/i);
    const qtdAlterada = qtdMatch ? parseInt(qtdMatch[1], 10) : 1; 

    // Verifica se a quantidade alterada √© v√°lida e se n√£o excede os dispon√≠veis (apenas um alerta, o controle final √© na transa√ß√£o)
    if (qtdAlterada < 1 || isNaN(qtdAlterada)) {
         return alert("√â obrigat√≥rio especificar a quantidade de unidades afetadas, ex: 'Quebrado QTD: 1'.");
    }
    
    // Dados do usu√°rio e data atual para padroniza√ß√£o
    const conf = `${userInfo.postoGraduacao} ${userInfo.quadro} ${userInfo.nomeGuerra}`; 
    const now = formatarDataSimples(new Date()); 

    // Garante que a observa√ß√£o tenha a quantidade explicitada para o log
    const logObs = obsRaw.includes(`QTD: ${qtdAlterada}`) ? obsRaw : `${obsRaw} | QTD: ${qtdAlterada}UN`;


    if (hist && hist.dataset.meta) {
        // L√≥gica de Acrescentar (Quando h√° uma pend√™ncia anterior)
        if (logObs.length < 3) return alert("Digite a altera√ß√£o."); 
        const meta = JSON.parse(decodeURIComponent(hist.dataset.meta)); 
        // Usa montarHistoricoLinear para manter o hist√≥rico formatado
        final = montarHistoricoLinear(meta.obs, logObs, meta.autor, meta.data);
    } else {
        // L√≥gica de Nova Altera√ß√£o (Primeira ocorr√™ncia)
        if (logObs.length < 3) return alert("Descreva a altera√ß√£o em detalhes (m√≠nimo 3 caracteres).");
        // Formata a PRIMEIRA observa√ß√£o com o padr√£o completo (para ser assinada no log)
        final = `${logObs}`; 
    } 

    // O status agora inclui a quantidade alterada para uso na transa√ß√£o final
    window.itemStatus[item.dataset.id] = { status: 'C/A', obs: final, qtd_alterada: qtdAlterada }; 
    item.querySelector('.alteracao-container').style.display = 'none'; 

    const d = item.querySelector('.descricao-salva'); 
    
    // Passamos o texto final e as informa√ß√µes do militar para o gerarHtmlVisual.
    d.innerHTML = gerarHtmlVisual(final, conf, now, null, null); 
    d.style.display = 'block'; 
    salvarRascunho(); 

    updateSetorStatus(btn.closest('.setor')); 
    updateOverallStatus(); 
    checkSetorCompletion(btn.closest('.setor'), item.dataset.id);
}

// A fun√ß√£o salvarTombamento n√£o precisa de altera√ß√£o de quantidade, pois a quantidade √© sempre 1.
// Apenas o padr√£o de carimbo de log √© o mesmo.

        function salvarTombamento(btn) { 
    const tomb = btn.closest('.tombamento-container'); 
    const item = btn.closest('.item-conferencia'); 
    const obs = tomb.querySelector('textarea').value.trim(); 
    const hist = tomb.querySelector('.historico-fixo'); 
    let final = obs; 

    // Dados do usu√°rio e data atual para padroniza√ß√£o
    const conf = `${userInfo.postoGraduacao} ${userInfo.quadro} ${userInfo.nomeGuerra}`; 
    const now = formatarDataSimples(new Date()); 

    if (hist && hist.dataset.meta) {
        // L√≥gica de Acrescentar (Quando h√° uma pend√™ncia anterior)
        if (obs.length < 3) return alert("Digite a altera√ß√£o."); 
        const meta = JSON.parse(decodeURIComponent(hist.dataset.meta));
        // Usa montarHistoricoLinear para concatenar a nova observa√ß√£o
        final = montarHistoricoLinear(meta.obs, obs, meta.autor, meta.data);
    } else {
        // L√≥gica de Nova Altera√ß√£o (Primeira ocorr√™ncia)
        if (obs.length < 3) return alert("Descreva a altera√ß√£o em detalhes (m√≠nimo 3 caracteres).");
        // Formata a PRIMEIRA observa√ß√£o com o padr√£o completo
        final = `${obs}`; // Usando template string limpo
    } 

    window.itemStatus[`${item.dataset.id}-${tomb.dataset.tomb}`] = { status: 'C/A', obs: final, qtd_alterada: 1 }; // Adiciona qtd_alterada: 1
    tomb.querySelector('.tombamento-obs-container').style.display = 'none'; 

    const d = tomb.querySelector('.tombamento-descricao-salva');
    
    // O gerarHtmlVisual agora recebe a string 'final' j√° formatada.
    d.innerHTML = gerarHtmlVisual(final, conf, now, null, null); 
    d.style.display = 'block'; 
    salvarRascunho(); 

    updateItemMainStatusDisplay(item); 
    updateSetorStatus(btn.closest('.setor')); 
    updateOverallStatus(); 
    checkSetorCompletion(btn.closest('.setor'), item.dataset.id); 
}

        function restaurarRascunho() {
            const saved = localStorage.getItem(getStorageKey()); if (!saved) return;
            try {
                const parsed = JSON.parse(saved); window.itemStatus = parsed.status; 
                document.getElementById('draft-message').style.display = 'block';
                Object.keys(window.itemStatus).forEach(uid => {
                    const st = window.itemStatus[uid]; let container, isTombamento=false;
                    container = document.querySelector(`.item-conferencia[data-id="${uid}"]`);
                    if (!container) {
                        const allTombs = document.querySelectorAll('.tombamento-container');
                        for (let t of allTombs) { if (`${t.closest('.item-conferencia').dataset.id}-${t.dataset.tomb}` === uid) { container = t; isTombamento = true; break; } }
                    }
                    if (container) {
                        const btnSA=container.querySelector('.sa-ok'), btnCA=container.querySelector('.ca-alert');
                        if(btnSA)btnSA.classList.remove('active'); if(btnCA)btnCA.classList.remove('active');
                        const descEl = container.querySelector('.descricao-salva') || container.querySelector('.tombamento-descricao-salva');
                        
                        if (st.status === 'S/A') { if(btnSA)btnSA.classList.add('active'); if(!isTombamento) container.querySelector('.status-icon').className='status-icon ok'; }
                        else if (st.status === 'C/A' || st.status === 'KEEP') { 
                            if(btnCA)btnCA.classList.add('active'); 
                            if(!isTombamento) container.querySelector('.status-icon').className='status-icon alert'; 
                            if(descEl && st.status === 'C/A') {
                                const conf=`${userInfo.postoGraduacao} ${userInfo.quadro} ${userInfo.nomeGuerra}`;
                                const now=formatarDataSimples(new Date());
                                descEl.innerHTML=gerarHtmlVisual(st.obs,conf,now,null,null); 
                                descEl.style.display='block';
                                const pendBox = container.querySelector('.pendencia-alert-box'); if(pendBox) pendBox.style.display = 'none';
                            } else if(st.status === 'KEEP') {
                                const pendBox = container.querySelector('.pendencia-alert-box');
                                if(pendBox) {
                                    pendBox.classList.add('kept'); pendBox.querySelector('.pendencia-actions').style.display='none';
                                    if(!pendBox.innerHTML.includes('‚úî Mantido')) pendBox.insertAdjacentHTML('beforeend', '<div style="color:#1b8a3e;font-weight:bold;font-size:0.9em;margin-top:5px;border-top:1px dashed #ccc;padding-top:3px;">‚úî Mantido</div>');
                                }
                            }
                        }
                        else if (st.status === 'PENDING_CA') {
                            const edit = container.querySelector('.tombamento-obs-container')||container.querySelector('.alteracao-container');
                            if(edit) edit.style.display='block';
                            if(btnCA) btnCA.classList.add('active');
                        }
                        if(isTombamento) updateItemMainStatusDisplay(container.closest('.item-conferencia'));
                    }
                });
                document.querySelectorAll('.setor').forEach(s => updateSetorStatus(s)); updateOverallStatus();
            } catch (e) { console.error("Erro restore", e); }
        }
        function adaptarCautelaParaRender(cautelaData) {
            if (!cautelaData.itens || cautelaData.itens.length === 0) return [];

            // Cria um setor √∫nico chamado "ITENS DA CAUTELA"
            const setorCautela = {
                id: cautelaData.cautela_id,
                nome: "ITENS CAUTELADOS",
                itens: cautelaData.itens.map(cItem => {
                    // Mapeia os dados da cautela para o formato esperado de um item de confer√™ncia
                    return {
                        id: cItem.id_completo || cItem.id_base, // Usa o ID completo (incluindo tombamento se multi)
                        nome: cItem.nome,
                        quantidadeEsperada: cItem.quantidade,
                        // Define como 'single' ou 'multi' dependendo se tem um tombamento ID ou se a quantidade √© 1
                        tipo: cItem.tipo, 
                        // A cautela √© tratada como um item novo, ent√£o n√£o h√° 'pendencia' inicial.
                    };
                })
            };

            return [setorCautela]; // Retorna a lista encapsulada em um array de setores.
        }
        async function carregarDadosRemotos() {
    // Se for uma cautela, o ID base √© o CAUTELA_ID. Caso contr√°rio, √© o LISTA_ID.
    const ID_ALVO = isCautela ? CAUTELA_ID : LISTA_ID;
    const COLECAO_ALVO = isCautela ? COLECAO_CAUTELAS : COLECAO_LISTAS;
    
    if (!ID_ALVO) { document.getElementById('loading-message').innerHTML = "<span style='color:red'>Erro: ID n√£o encontrado.</span>";
        return; }
        
    document.getElementById('loading-message').innerHTML = "Conectando...";
    try {
        const doc = await db.collection(COLECAO_ALVO).doc(ID_ALVO).get();
        if (!doc.exists) throw new Error("Documento n√£o encontrado.");
        
        const data = doc.data();
        
        // Estrutura de dados: 
        dadosConferencia = isCautela ? adaptarCautelaParaRender(data) : (data.list || []);
        
        // Informa√ß√µes do Local/T√≠tulo:
        const nomeLocal = isCautela ? `CAUTELA: ${CAUTELA_ID}` : (data.nome_local || "DESCONHECIDO");
        const postoLocal = isCautela ? `Destinat√°rio: ${data.destinatario}` : (data.posto || "Geral");
        
        infoLocal = { nome: nomeLocal, posto: postoLocal };
        
        document.getElementById('local-posto-info').innerHTML = `<span style="color:blue;font-weight:bold">${infoLocal.posto} - ${infoLocal.nome}</span>`;
        document.title = isCautela ? `Cautela - ${CAUTELA_ID}` : `Confer√™ncia - ${infoLocal.posto} ${infoLocal.nome}`;

        if (isCautela) { // Apenas executa para cautelas
            const h1Element = document.querySelector('.container h1');
            const subtituloElement = document.querySelector('.container .subtitulo');
            const btnFinalizar = document.getElementById('btn-finalizar');

            // üõë L√≥gica do NOVO modo: CONFER√äNCIA DE RECEBIMENTO DE DEVOLU√á√ÉO (Dono Provis√≥rio)
            if (MODO_OPERACAO === 'devolucao_final') {
                h1Element.textContent = 'CONFER√äNCIA DE RECEBIMENTO DE DEVOLU√á√ÉO';
                
                // Exibe o militar que enviou (reversor), que est√° no campo 'reversor' da cautela (data)
                const reversor = data.militar_completo_reversor || 'Militar Anterior';
                subtituloElement.innerHTML = `Recebendo a Devolu√ß√£o da Cautela <span style="font-weight: bold;">${CAUTELA_ID}</span> do Militar: <br> <strong>${reversor}</strong>`;
                
                btnFinalizar.textContent = 'FINALIZAR RECEBIMENTO DA DEVOLU√á√ÉO';
                btnFinalizar.onclick = () => finalizarRecebimentoDevolucao(data); // Chamada √† nova fun√ß√£o
                
                btnFinalizar.classList.add('btn-sync'); 
                btnFinalizar.classList.remove('btn-action', 'btn-delete');
                
            // L√≥gica do modo DEVOLU√á√ÉO (Antigo fluxo Usu√°rio A, que agora n√£o deveria ser conferido)
            } else if (MODO_OPERACAO === 'devolucao') {
                h1Element.textContent = 'CONFER√äNCIA DE DEVOLU√á√ÉO (TRANSI√á√ÉO)';
                
                subtituloElement.innerHTML = `Devolu√ß√£o da Cautela <span style="font-weight: bold;">${CAUTELA_ID}</span> para: <br> <strong>${DESTINATARIO_DEVOLUCAO}</strong>`;
                
                btnFinalizar.textContent = 'FINALIZAR DEVOLU√á√ÉO E CONCLUIR';
                btnFinalizar.onclick = () => finalizarDevolucaoCautela(data);
                btnFinalizar.classList.add('btn-delete');
                btnFinalizar.classList.remove('btn-action');
                
            } else {
                // L√≥gica de Recebimento (padr√£o)
                h1Element.textContent = 'CONFER√äNCIA DE RECEBIMENTO';
                subtituloElement.textContent = `Recebimento da Cautela ${CAUTELA_ID}`;
                
                btnFinalizar.textContent = 'FINALIZAR RECEBIMENTO';
                btnFinalizar.onclick = () => finalizarRecebimentoCautela(data);
                btnFinalizar.classList.add('btn-action');
                btnFinalizar.classList.remove('btn-delete', 'btn-sync');
            }
        }
        
        document.getElementById('loading-message').innerHTML = "Renderizando...";
        renderizarConferencia(); updateHeaderInfo(); updateOverallStatus(); restaurarRascunho();
        document.getElementById('loading-message').style.display='none'; document.getElementById('main-content').style.display='block';
    } catch (e) { document.getElementById('loading-message').innerHTML = "Erro: " + e.message;
    }
}

        async function finalizarConferencia() {
    if (isCautela) {
        // Se for uma cautela, chame a fun√ß√£o espec√≠fica de finaliza√ß√£o de recebimento.
        // O c√≥digo de finaliza√ß√£o de cautela est√° correto para usar as fun√ß√µes espec√≠ficas.
        return;
    }
    
    // L√ìGICA DE FINALIZA√á√ÉO DE CONFER√äNCIA NORMAL (Com Nova L√≥gica de Estoque)
    const btn = document.getElementById('btn-finalizar');
    if (btn.disabled) return;
    btn.textContent = "Salvando..."; btn.disabled = true;

    try {
        const p = userInfo;
        const conferente = `${p.postoGraduacao} ${p.quadro} ${p.nomeGuerra}`;
        const localNome = `${infoLocal.posto} - ${infoLocal.nome}`;
        const clean = (val) => val === undefined ? null : val;
        let updated = false;
        const statusRascunho = window.itemStatus || {};
        
        // --- IN√çCIO DA TRANSA√á√ÉO (simulada via lock impl√≠cito no bot√£o e update) ---

        const atualizarListaDB = (itemOuTomb, uid) => {
            const s = statusRascunho[uid];
            if (!s || s.status === 'pending') return;

            let old = itemOuTomb.pendencia || {};

            // 1. ATUALIZA O LOG E STATUS C/A/S/A/KEEP
            if (s.status === 'C/A' || s.status === 'KEEP') {
                // Se for C/A, usa o novo log salvo. KEEP (Ciente) usa o log original (pend√™ncia de cautela)
                const obsLog = s.status === 'C/A' ? s.obs : old.obs;
                
                // Aplica o status e o log
                itemOuTomb.pendencia = { 
                    obs: obsLog, 
                    quem: conferente, 
                    data: firebase.firestore.Timestamp.now(), 
                    status: s.status, // C/A ou KEEP
                    statusAdmin: clean(old.statusAdmin), 
                    adminObs: clean(old.adminObs) 
                };
                updated = true;

                // 2. ATUALIZA RASTREIO DE QUANTIDADE (APENAS PARA ITEM SINGLE)
                if (itemOuTomb.tipo === 'single' && s.status === 'C/A' && s.qtd_alterada > 0) {
                    itemOuTomb.quantidadeComAlteracao = (itemOuTomb.quantidadeComAlteracao || 0) + s.qtd_alterada;
                    // Note: Se o status for KEEP, o item j√° estava em Cautela e a quantidade n√£o muda aqui.
                }
                
                // 3. ATUALIZA STATUS DE CONFER√äNCIA (Multi-Tombamento)
                if(itemOuTomb.tomb) {
                    itemOuTomb.status_conferencia = 'CA';
                }

            } else if (s.status === 'S/A') { 
                // Status S/A: Remove a pend√™ncia e restaura o status de confer√™ncia
                if (itemOuTomb.pendencia) delete itemOuTomb.pendencia; 
                if (itemOuTomb.tomb) itemOuTomb.status_conferencia = 'OK';
                updated = true;
            }
        };

        // Aplica as altera√ß√µes no array local 'dadosConferencia'
        dadosConferencia.forEach(setor => {
            setor.itens.forEach(item => {
                if(item.tipo === 'single') atualizarListaDB(item, item.id);
                else if(item.tombamentos) item.tombamentos.forEach(t => atualizarListaDB(t, `${item.id}-${t.tomb}`));
            });
        });
        
        // --- COPIANDO C√ìDIGO DE RELAT√ìRIO DO SEU ORIGINAL ---
        let itensRelatorio = []; let itensCaa = []; let itemsCount = 0; let cA_count = 0;
        
        dadosConferencia.forEach(setor => {
            setor.itens.forEach(item => {
                const process = (id, nome, pend, qtd) => {
                    const s = statusRascunho[id];
                    if (s && s.status !== 'pending') {
                        itemsCount++;
                        let finalStatus = s.status === 'KEEP' ? 'C/A' : s.status;
                        if (s.status === 'C/A' || s.status === 'KEEP') cA_count++;
                        let finalObs = s.obs;
                        if (s.status === 'KEEP' && pend) finalObs = pend.obs;
                        if (s.status === 'S/A') finalObs = null;
                        
                        const dadosItem = { 
                            nomeCompleto: nome, 
                            status: finalStatus, 
                            obs: finalObs, 
                            quantidade: qtd || 1, 
                            id: id,
                            statusAdmin: pend ? clean(pend.statusAdmin) : null,
                            adminObs: pend ? clean(pend.adminObs) : null,
                            setor: setor.nome
                        };
                        itensRelatorio.push(dadosItem);
                        if (s.status === 'C/A' || s.status === 'KEEP') itensCaa.push(dadosItem);
                    }
                };
                if (item.tipo === 'multi' && item.tombamentos) item.tombamentos.forEach(t => process(`${item.id}-${t.tomb}`, `${item.nome} (${t.tomb})`, t.pendencia, 1));
                else process(item.id, item.nome, item.pendencia, item.quantidadeEsperada);
            });
        });
        // --- FIM DA C√ìPIA DO C√ìDIGO DE RELAT√ìRIO ---
        
        // 4. SALVAMENTO FINAL NO FIREBASE
        if (updated) await db.collection(COLECAO_LISTAS).doc(LISTA_ID).update({ list: dadosConferencia });
        
        await db.collection('resultados_conferencias').add({ local: localNome, lista_id: LISTA_ID, conferente, timestamp: firebase.firestore.Timestamp.now(), totalItensConferidos: itemsCount, totalCaa: cA_count, itensCaa, itensRelatorio });

        const militarCompleto = `${p.postoGraduacao} ${p.quadro} ${p.nomeGuerra}`;
        await db.collection('custodia_atual').doc(LISTA_ID).set({
            local_nome: localNome,
            conferente_completo: militarCompleto, 
            timestamp_custodia: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        // --- FIM DA TRANSA√á√ÉO ---

        limparRascunho();
        window.parent.postMessage({ type: 'SIGMA_FINISHED' }, '*');
        if (window.self === window.top) { alert("Salvo! Redirecionando..."); window.location.href = "operacional.html"; }

    } catch (e) { console.error(e); alert("Erro: " + e.message); btn.disabled = false; }
}
        async function finalizarRecebimentoCautela() {
    const btn = document.getElementById('btn-finalizar');
    btn.textContent = "Confirmando posse...";
    
    // Coleta o status final de cada item conferido (ainda necess√°rio para o futuro relat√≥rio C/A)
    const itensConferidos = Object.entries(window.itemStatus)
        .filter(([id, status]) => status.status !== 'pending')
        .map(([id, status]) => ({ id: id, status: status.status }));

    if (itensConferidos.length === 0) {
        alert("Nenhum item foi conferido. A cautela n√£o ser√° finalizada.");
        btn.textContent = "FINALIZAR CONFER√äNCIA";
        btn.disabled = false;
        return;
    }

    try {
        await db.runTransaction(async (transaction) => {
            const cautelaRef = db.collection('cautelas_abertas').doc(CAUTELA_ID);
            const cautelaDoc = await transaction.get(cautelaRef);
            
            if (!cautelaDoc.exists || cautelaDoc.data().status !== 'ABERTA') {
                throw new Error("Cautela n√£o encontrada ou j√° processada.");
            }
            
            // üõë CR√çTICO: N√£o precisamos da Lista Mestra aqui, pois n√£o h√° altera√ß√£o de invent√°rio.
            // Apenas atualizamos o status e o documento da cautela.

            // 1. A√ß√£o: Mudar o status da cautela para indicar que foi RECEBIDA.
            transaction.update(cautelaRef, { 
                status: 'RECEBIDA', // Status intermedi√°rio
                timestamp_recebimento: firebase.firestore.FieldValue.serverTimestamp(),
                receptor: userInfo.nomeGuerra, // Nome de guerra do militar que recebeu
                militar_completo_receptor: `${userInfo.postoGraduacao} ${userInfo.quadro} ${userInfo.nomeGuerra}`, // Nome completo para futuras buscas
            });
            
            // Nota: Se houver itens C/A, eles DEVEM ser registrados em um relat√≥rio √† parte (melhoria futura).

        }); // Fim da Transa√ß√£o

        alert(`‚úÖ Cautela ${CAUTELA_ID} confirmada e status atualizado para "RECEBIDA".`);
        limparRascunho();
        window.parent.postMessage({ type: 'SIGMA_FINISHED' }, '*');
        
    } catch (error) {
        console.error("Erro CR√çTICO ao confirmar recebimento:", error);
        alert(`Erro ao confirmar recebimento. Nenhum dado foi alterado. Erro: ${error.message}`);
        btn.textContent = "ERRO AO FINALIZAR";
        btn.disabled = false;
    }
}
      async function finalizarDevolucaoCautela(cautela) {
    const btn = document.getElementById('btn-finalizar');
    btn.textContent = 'Processando...';
    btn.disabled = true;

    try {
        // Pega as informa√ß√µes do militar logado (quem est√° devolvendo)
        const userInfo = await getLoggedUser(); 
        
        if (!userInfo) {
            alert("Erro: Dados do militar logado n√£o encontrados.");
            btn.textContent = 'ERRO AO FINALIZAR';
            btn.disabled = false;
            return;
        }

        const cautelaRef = db.collection(COLECAO_CAUTELAS).doc(CAUTELA_ID);

        // üõë CR√çTICO: Executa a Transa√ß√£o no Firebase üõë
        await db.runTransaction(async (transaction) => {
            const doc = await transaction.get(cautelaRef);

            if (!doc.exists || doc.data().status !== 'RECEBIDA') {
                throw new Error("Cautela n√£o encontrada ou n√£o est√° no status 'RECEBIDA'.");
            }
            
            // 1. A√ß√£o: Mudar o status da cautela para CONCLUIDA.
            transaction.update(cautelaRef, { 
                status: 'CONCLUIDA', // Status final
                timestamp_devolucao: firebase.firestore.FieldValue.serverTimestamp(),
                
                // Quem est√° devolvendo (Militar Logado)
                reversor: userInfo.nomeGuerra, 
                militar_completo_reversor: `${userInfo.postoGraduacao} ${userInfo.quadro} ${userInfo.nomeGuerra}`,
                
                // Quem est√° recebendo de volta (√öltimo Conferente)
                destinatario_final_devolucao: DESTINATARIO_DEVOLUCAO,
            });
            
            // 2. A√ß√£o: Registrar o hist√≥rico de confer√™ncia final (opcional, mas recomendado)
            // Se necess√°rio, voc√™ pode adicionar um novo documento na sua cole√ß√£o de hist√≥rico.
        }); // Fim da Transa√ß√£o

        alert(`‚úÖ Devolu√ß√£o da Cautela ${CAUTELA_ID} conclu√≠da e status atualizado para \"CONCLUIDA\".`);
        limparRascunho();
        window.parent.postMessage({ type: 'SIGMA_FINISHED' }, '*');
        
    } catch (error) {
        console.error("Erro CR√çTICO ao finalizar devolu√ß√£o:", error);
        alert(`Erro ao finalizar devolu√ß√£o. Nenhum dado foi alterado. Erro: ${error.message}`);
        btn.textContent = "ERRO AO FINALIZAR";
        btn.disabled = false;
    }
}
        /**
 * FINALIZA A DEVOLU√á√ÉO: Executa a transa√ß√£o final para somar os itens de volta √† Lista Mestra 
 * e mudar o status da cautela para CONCLU√çDA (Finalizada e enviada ao hist√≥rico).
 * @param {object} cautela - O objeto de dados da cautela.
 */
async function finalizarRecebimentoDevolucao(cautela) {
    const btn = document.getElementById('btn-finalizar');
    btn.textContent = "PROCESSANDO...";
    btn.disabled = true;

    const listaId = cautela?.local_origem_id; 

    if (!cautela || !CAUTELA_ID || !listaId) {
        console.error("ERRO FATAL: Dados cr√≠ticos ausentes. ", { cautelaValid: !!cautela, CAUTELA_ID: CAUTELA_ID, LISTA_ID: listaId });
        alert("Erro: Dados iniciais incompletos ou inv√°lidos. Tente novamente.");
        btn.textContent = "ERRO AO FINALIZAR";
        btn.disabled = false;
        return;
    }

    const militarCompleto = `${userInfo?.postoGraduacao} ${userInfo?.quadro} ${userInfo?.nomeGuerra}`;
    const dataConclusaoFormatada = new Date().toLocaleDateString('pt-BR');

    try {
        const cautelaRef = db.collection(COLECAO_CAUTELAS).doc(CAUTELA_ID);
        const listaMestraRef = db.collection(COLECAO_LISTAS).doc(listaId);

        await db.runTransaction(async (transaction) => {
            const cautelaDoc = await transaction.get(cautelaRef);
            const listaMestraDoc = await transaction.get(listaMestraRef);
            
            const currentStatus = cautelaDoc.exists && cautelaDoc.data().status ? cautelaDoc.data().status : "";
            
            if (!cautelaDoc.exists || currentStatus.trim().toUpperCase() !== 'DEVOLU√á√ÉO') {
                console.warn(`Transa√ß√£o abortada. Status lido (limpo): ${currentStatus.trim().toUpperCase()}`); 
                throw new Error(`Cautela n√£o est√° no status 'DEVOLU√á√ÉO'. Status atual: ${currentStatus}`);
            }

            if (!listaMestraDoc.exists) {
                throw new Error("Lista Mestra de Confer√™ncia (Origem) n√£o encontrada!");
            }
            
            let listaMestra = listaMestraDoc.data().list;
            
            // L√ìGICA DE REVERS√ÉO DE CARIMBO (RASTREIO) E DISPONIBILIDADE
            cautela.itens.forEach(cItem => {
                const itemQtd = cItem.quantidade || 0;
                
                listaMestra = listaMestra.map(setor => ({
                    ...setor,
                    itens: setor.itens.map(mItem => {
                        if (mItem.id === cItem.id_base) {
                            let carimboTexto = '';
                            
                            if (cItem.tipo === 'single') {
                                // L√ìGICA 1: Item Sem Tombamento (single)
                                
                                // Decrementa a quantidade cautelada (aumenta a disponibilidade)
                                mItem.quantidadeCautelada = (mItem.quantidadeCautelada || 0) - itemQtd;
                                if (mItem.quantidadeCautelada < 0) mItem.quantidadeCautelada = 0;
                                
                                carimboTexto = `[CAUTELA-${CAUTELA_ID}: RECEBIDA] ${itemQtd}UN Restauradas. Status: CONCLU√çDA`;

                            } else if (cItem.tipo === 'multi' && mItem.tombamentos) {
                                // L√ìGICA 2: Item Com Tombamento (multi)
                                
                                mItem.tombamentos = mItem.tombamentos.map(tomb => {
                                    // Limpa o carimbo interno do tombamento que est√° sendo devolvido
                                    if (tomb.tomb === cItem.tombamento && tomb.cautela_id === CAUTELA_ID) {
                                        delete tomb.cautela_id; 
                                        delete tomb.destinatario;
                                    }
                                    return tomb;
                                });
                                
                                carimboTexto = `[CAUTELA-${CAUTELA_ID}: RECEBIDA] Tomb: ${cItem.tombamento} Restaurado. Status: CONCLU√çDA`;
                            }

                            // Carimbo no Hist√≥rico Unificado (pendencia.obs)
                            if (carimboTexto) {
                                mItem.pendencia = mItem.pendencia || {};
                                mItem.pendencia.obs = mItem.pendencia.obs || '';
                                
                                mItem.pendencia.obs = montarHistoricoLinear(
                                    mItem.pendencia.obs, 
                                    carimboTexto,
                                    militarCompleto, 
                                    dataConclusaoFormatada
                                );

                                // Verifica se ainda h√° cautelas ativas para este item para reverter o status 'CAUTELADO'
                                const isStillCautelado = (mItem.tipo === 'single' && (mItem.quantidadeCautelada || 0) > 0) || 
                                                         (mItem.tipo === 'multi' && mItem.tombamentos.some(t => t.cautela_id));
                                
                                if (!isStillCautelado) {
                                    mItem.pendencia.status = 'OK';
                                }
                            }
                        }
                        return mItem;
                    })
                }));
            });
            // FIM DA L√ìGICA DE REVERS√ÉO
            
            // 3. A√ß√£o: Mudar o status da cautela para CONCLUIDA (Vai para o Hist√≥rico)
            transaction.update(cautelaRef, { 
                status: 'CONCLU√çDA', 
                timestamp_conclusao: firebase.firestore.FieldValue.serverTimestamp(),
                receptor_final_completo: militarCompleto,
            });
            
            // 4. A√ß√£o: Atualizar a Lista Mestra com o rastreio corrigido
            transaction.update(listaMestraRef, { list: listaMestra });

        }); // Fim da Transa√ß√£o

        alert(`‚úÖ Devolu√ß√£o da Cautela ${CAUTELA_ID} confirmada e rastreamento restaurado. Status: CONCLU√çDA.`);
        limparRascunho();
        window.parent.postMessage({ type: 'SIGMA_FINISHED' }, '*');
        
    } catch (error) {
        console.error("Erro CR√çTICO ao finalizar devolu√ß√£o e restaurar estoque:", error);
        alert(`Erro ao finalizar devolu√ß√£o. Nenhum dado foi alterado. Erro: ${error.message}`);
        btn.textContent = "ERRO AO FINALIZAR";
        btn.disabled = false;
    }
}
        window.onload = carregarDadosRemotos;
        /**
 * Fun√ß√£o Administrativa CR√çTICA: Limpa o status de Pend√™ncia/Cautela de um item na Lista Mestra.
 * Deve ser usada APENAS para testes.
 * @param {string} listaId - O ID da lista a ser atualizada (Ex: 'ALFA - PERMANENCIA').
 * @param {string} itemId - O ID do item principal (sem tombamento, Ex: 'ITEM-001').
 */
async function limparStatusDeItemParaTeste(listaId, itemId) {
    if (!confirm(`ATEN√á√ÉO: Voc√™ tem certeza que deseja LIMPAR o status de Pend√™ncia/Cautela do item ${itemId} na lista ${listaId}? Isso √© IRREVERS√çVEL no log de C/A!`)) {
        return;
    }

    try {
        const listaMestraRef = db.collection('listas_conferencia').doc(listaId);
        
        await db.runTransaction(async (transaction) => {
            const listaMestraDoc = await transaction.get(listaMestraRef);
            if (!listaMestraDoc.exists) throw new Error("Lista Mestra n√£o encontrada!");
            
            let listaMestra = listaMestraDoc.data().list;
            let itemEncontrado = false;
            
            listaMestra.forEach(setor => {
                setor.itens = setor.itens.map(mItem => {
                    if (mItem.id === itemId) {
                        itemEncontrado = true;
                        
                        // üõë 1. LIMPEZA DOS CARIMBOS E RASTREIOS
                        delete mItem.pendencia; // Remove todo o hist√≥rico (Log) e status
                        delete mItem.quantidadeCautelada; // Zera o rastreio de cautela (single)
                        delete mItem.quantidadeComAlteracao; // Zera o rastreio de C/A (single)
                        
                        // üõë 2. LIMPEZA DOS TOMBAMENTOS (se multi)
                        if (mItem.tipo === 'multi' && mItem.tombamentos) {
                            mItem.tombamentos = mItem.tombamentos.map(tomb => {
                                delete tomb.cautela_id;
                                delete tomb.destinatario;
                                delete tomb.pendencia; // Remove pend√™ncia individual do tombamento
                                tomb.status_conferencia = 'PENDING'; // Reseta o status de confer√™ncia
                                return tomb;
                            });
                        }
                    }
                    return mItem;
                });
            });

            if (!itemEncontrado) {
                throw new Error(`Item ${itemId} n√£o encontrado na lista.`);
            }

            // Salva a lista limpa
            transaction.update(listaMestraRef, { list: listaMestra });
        });

        alert(`‚úÖ Sucesso! Item ${itemId} na lista ${listaId} foi limpo.`);
        location.reload(); // Recarrega para ver as mudan√ßas

    } catch (error) {
        console.error("Erro ao limpar status do item:", error);
        alert(`Falha na limpeza. Erro: ${error.message}`);
    }
}
        /**
 * Inicia o processo de lan√ßamento de uma ou mais unidades em C/A para um item 'single'.
 * Usa prompts para coletar QTD e OBS.
 * @param {string} itemId - O ID do item a ser alterado.
 * @param {boolean} isAppending - Indica se √© uma nova altera√ß√£o (true) ou o in√≠cio (false).
 */
function lancarNovaAlteracao(itemId, isAppending) {
    const item = document.querySelector(`.item-conferencia[data-id="${itemId}"]`);
    if (!item) return;

    const qtdDisplay = item.querySelector('.item-quantidade').textContent;
    const dispMatch = qtdDisplay.match(/(\d+)\s+DISP/);
    const totalDisponivelAtual = dispMatch ? parseInt(dispMatch[1], 10) : 0;
    
    if (totalDisponivelAtual <= 0) {
        alert("N√£o h√° mais unidades dispon√≠veis para lan√ßamento de altera√ß√£o.");
        return;
    }

    const obsExistente = window.itemStatus[itemId]?.obs || '';

    const qtdInput = prompt(`Unidades Dispon√≠veis: ${totalDisponivelAtual}.\n\nQuantas unidades ser√£o registradas com altera√ß√£o (C/A)?`);

    if (qtdInput === null) return;
    
    const qtdAlterada = parseInt(qtdInput.trim(), 10);
    
    if (isNaN(qtdAlterada) || qtdAlterada <= 0) {
        alert("Quantidade inv√°lida. Opera√ß√£o cancelada.");
        return;
    }

    if (qtdAlterada > totalDisponivelAtual) {
        alert(`Voc√™ s√≥ pode alterar at√© ${totalDisponivelAtual} unidades dispon√≠veis. Opera√ß√£o cancelada.`);
        return;
    }
    
    const obsInput = prompt(`Descreva a altera√ß√£o para ${qtdAlterada} UNIDADES: (Ex: "Rasgado")`);

    if (!obsInput || obsInput.trim().length < 3) {
        alert("A descri√ß√£o da altera√ß√£o √© obrigat√≥ria. Opera√ß√£o cancelada.");
        return;
    }
    
    const obsBruta = obsInput.trim();
    const conf = `${userInfo.postoGraduacao} ${userInfo.quadro} ${userInfo.nomeGuerra}`;
    const now = formatarDataSimples(new Date());

    let finalLog = '';
    const logObs = `${obsBruta} | QTD: ${qtdAlterada}UN`;

    if (isAppending && obsExistente) {
        finalLog = montarHistoricoLinear(obsExistente, logObs, conf, now);
    } else {
        finalLog = logObs;
    }
    
    const currentQtdTotal = window.itemStatus[itemId]?.qtd_alterada || 0;
    const setor = item.closest('.setor');
    
    window.itemStatus[itemId] = { 
        status: 'C/A', 
        obs: finalLog, 
        qtd_alterada: currentQtdTotal + qtdAlterada 
    };
    
    item.classList.add('status-alert');
    item.querySelector('.status-icon').className = 'status-icon alert';
    
    const d = item.querySelector('.descricao-salva');
    d.innerHTML = gerarHtmlVisual(finalLog, conf, now, null, null);
    d.style.display = 'block';

    recalcularESyncDisplay(item, setor);
    salvarRascunho();
}
        function scrollToNextPendingItem(currentItemId) {
    const allItems = Array.from(document.querySelectorAll('.item-conferencia'));
    
    let nextPendingItem = null;
    let foundCurrent = false;

    for (const itemEl of allItems) {
        if (itemEl.dataset.id === currentItemId) {
            foundCurrent = true;
            continue;
        }

        // Se √© o pr√≥ximo item (ap√≥s o conclu√≠do) e ainda est√° pendente (sem status ok ou alert)
        if (foundCurrent && !itemEl.classList.contains('status-ok') && !itemEl.classList.contains('status-alert')) {
            nextPendingItem = itemEl;
            break;
        }
    }

    if (nextPendingItem) {
        // Rola suavemente para o in√≠cio do pr√≥ximo item
        nextPendingItem.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
}
        /**
 * Recalcula o status de DISPON√çVEL/TOTAL na tela com base no rascunho (window.itemStatus).
 * Deve ser chamado ap√≥s qualquer altera√ß√£o (C/A ou S/A).
 */
/**
 * Recalcula o status de DISPON√çVEL/TOTAL na tela com base no rascunho (window.itemStatus).
 * Atualiza o display visual e dispara checagens de conclus√£o de setor.
 */
function recalcularESyncDisplay(itemEl, setorEl) {
    const itemId = itemEl.dataset.id;
    // Assume-se que 'dadosConferencia' √© global e cont√©m os dados mestres
    const itemData = dadosConferencia.flatMap(s => s.itens).find(i => i.id === itemId);
    if (!itemData) return;

    let totalEsperado = itemData.quantidadeEsperada || 0;
    let totalCautelado = itemData.quantidadeCautelada || 0;

    // A quantidade total alterada √© a soma do rascunho (qtdLancadaNoRascunho) mais o que j√° estava no backend
    const qtdLancadaNoRascunho = window.itemStatus[itemId]?.qtd_alterada || 0;
    // NOTA: Assumimos que a quantidadeComAlteracao do backend √© zero ao carregar a lista,
    // caso contr√°rio, precisar√≠amos subtrair o que j√° estava l√° se o S/A zerasse o log.
    const totalComAlteracao = qtdLancadaNoRascunho; 
    
    // Calcula o novo estoque vis√≠vel
    const totalIndisponivel = totalCautelado + totalComAlteracao;
    const totalDisponivel = totalEsperado - totalIndisponivel;
    
    // Obt√©m o status do rascunho
    const currentStatus = window.itemStatus[itemId]?.status;
    
    // 1. Atualiza o display de quantidade no item
    itemEl.querySelector('.item-quantidade').innerHTML = `${totalDisponivel} DISP. / ${totalEsperado} TOTAL`;
    
    // 2. Atualiza o estado visual (Classes de cores e √≠cones)
    if (currentStatus === 'S/A' && totalComAlteracao === 0) {
        // 100% OK (sem log C/A e marcado S/A)
        itemEl.className = 'item-conferencia status-ok';
        itemEl.querySelector('.status-icon').className = 'status-icon ok'; // √çcone CHECK (‚úì)
    } else if (currentStatus === 'C/A' || totalComAlteracao > 0) {
        // Houve alguma altera√ß√£o (C/A). Mant√©m o alerta
        itemEl.className = 'item-conferencia status-alert';
        itemEl.querySelector('.status-icon').className = 'status-icon alert'; // √çcone ALERTA/VERMELHO
    } else {
        // Pending inicial (ou indefinido)
        itemEl.className = 'item-conferencia';
        itemEl.querySelector('.status-icon').className = 'status-icon'; 
    }

    // 3. Atualiza o estado dos bot√µes (C/A, S/A, Acrescentar)
    updateItemStatusButtons(itemEl, itemId, totalDisponivel);

    // 4. Atualiza os contadores globais
    updateSetorStatus(setorEl);
    updateOverallStatus();

    // 5. Verifica conclus√£o do item (Se esgotou o dispon√≠vel ou se foi marcado S/A)
    if (totalDisponivel <= 0 || currentStatus === 'S/A') {
        checkSetorCompletion(setorEl, itemId);
    }
}
      /**
 * Gerencia a exibi√ß√£o dos bot√µes de a√ß√£o C/A para itens single: C/A inicial vs. Acrescentar.
 * Mant√©m o bot√£o S/A sempre vis√≠vel como op√ß√£o de desfazer/finalizar OK.
 */
function updateItemStatusButtons(item, itemId, qtdRestante) {
    const itemOptions = item.querySelector('.item-options');
    const currentQtdTotal = window.itemStatus[itemId]?.qtd_alterada || 0;
    
    // Se todas as unidades dispon√≠veis foram lan√ßadas em C/A.
    if (qtdRestante <= 0 && currentQtdTotal > 0) {
        itemOptions.innerHTML = `<span style="font-weight: bold; color: #d90f23;">C/A (TOTALMENTE ALTERADO)</span>`;
        return;
    }

    let ca_onclick_action;
    
    if (currentQtdTotal > 0) {
        // Se j√° tem C/A lan√ßado, o bot√£o C/A deve chamar a fun√ß√£o para ACRESCENTAR
        ca_onclick_action = `lancarNovaAlteracao('${itemId}', true)`;
    } else {
        // Se n√£o tem C/A, o bot√£o C/A deve chamar setItemStatus, iniciando o processo
        ca_onclick_action = `setItemStatus(this, 'alert')`;
    }
    
    // O bot√£o ativo deve ser o C/A se o status for 'C/A' para manter o feedback visual.
    const isActive = window.itemStatus[itemId]?.status === 'C/A' ? 'active' : '';
    const isSAActive = window.itemStatus[itemId]?.status === 'S/A' ? 'active' : '';

    itemOptions.innerHTML = `
        <button class="action-button sa-ok ${isSAActive}" onclick="setItemStatus(this, 'ok')">S/A</button>
        <button class="action-button ca-alert ${isActive}" onclick="${ca_onclick_action}">C/A ${currentQtdTotal > 0 ? '‚ûï' : ''}</button>
    `;
}
    </script>
</body>
</html>
